# You will need imports numpy and scipy.iio.wavfile
from typing import Sized
import numpy
import scipy.io.wavfile as wf


class AudioFrames(Sized):
    """AudioFrames
    A class for iterating over frames of audio data
    """

    def __init__(self, file_name, adv_ms, frame_ms):
        """"AudioFrames(filename, adv_ms, len_ms)
        Create a stream of audio frames where each is in len_ms milliseconds long
        and frames are advanced by adv_ms."""

        self.file_name = file_name
        self.sample_rate, self.audio_data = wf.read(self.file_name)
        signal_samples = len(self.audio_data)
        signal_len_ms = int(numpy.ceil(signal_samples / self.sample_rate)) * 1000
        adv_samples = int(numpy.ceil(self.sample_rate * adv_ms / 1000))
        frame_samples = int(numpy.ceil(self.sample_rate * frame_ms / 1000))
        self.frame_samples = min(frame_samples, signal_samples)
        self.adv_samples = min(adv_samples, self.frame_samples)
        self.frame_ms = min(frame_ms, signal_len_ms)
        self.adv_ms = min(adv_ms, self.frame_ms)

        frame_list = list()

        frames_num = int(numpy.ceil((signal_samples - self.frame_samples) / self.adv_samples)) + 1

        for i in range(frames_num):
            sample_list_frame = list()
            if i == 0:
                for j in range(self.frame_samples):
                    sample_list_frame.append(self.audio_data[j])
            else:
                for j in range(self.frame_samples):
                    if i * adv_samples + j >= signal_samples:
                        sample_list_frame.append(0.00001)
                    else:
                        sample_list_frame.append(self.audio_data[i * adv_samples + j])
            frame_list.append(numpy.asarray(sample_list_frame))

        self.frames = numpy.asarray(frame_list)
        self.iterator = iter(self.frames)

    def __len__(self):
        """len() - number of frames"""
        return len(self.frames)

    def __iter__(self):
        """"iter() - Return a frame iterator
         (Multiple iterators on same soundfile are not guaranteed to work as expected)
         """
        return self.iterator

    def __getitem__(self, item):
        return self.frames[item]

    # Implementation decision
    # You can return self and implement a __next__(self) in this class
    # or you can create and return an instance of an iteration class
    # of your design that supports __next__(self).

    def get_framelen_samples(self):
        """get_framelen_ms - Return frame length in samples"""

        return self.frame_samples

    def get_framelen_ms(self):
        """get_framelen_ms - Return frame length in ms"""

        return self.frame_ms

    def get_frameadv_samples(self):
        """get_frameadv_ms - Return frame advance in samples"""

        return self.adv_samples

    def get_frameadv_ms(self):
        """get_frameadv_ms - Return frame advance in ms"""

        return self.adv_ms

    def get_Fs(self):
        """get_Fs() - Return sample rate"""

        return self.sample_rate

    def get_Nyquist(self):
        """get_Nyquist - Return Nyquist rate (highest frequency that can
                be represented with the sample rate.
                """
        return self.sample_rate / 2

    def get_params(self):
        """Return dictionary with file parameters
            fields:
                filename - name of sound file
                Fs - sample rate
                framing - nested dictionary with fields:
                    adv_ms - frame advance in ms
                    len_ms - frame length in ms
                    adv_N, len_N - frame advance & length in samples
        """
        framing = {'adv_ms': self.adv_ms, 'len_ms': self.frame_ms, 'adv_N': self.adv_samples,
                   'len_N': self.frame_samples}
        return {'filename': self.file_name, 'Fs': self.sample_rate, 'framing': framing}

    def shape(self):
        """shape() - shape of tensor generated by iterator
        Returns a numpy array containing the dimensions of each frame.

        This will be useful later on.  Tensors are generalizations of
        vectors and matrices (see Wolfram MathWorld for a concise definition)
        and generally can be thought of as arbitrary-dimensioned matrices.
        """

        # You can create a numpy array from list l with np.asarray(l)
        dimensions_list = list()
        dimensions_list.append(1)
        dimensions_list.append(self.frame_samples)
        return numpy.asarray(dimensions_list)


def size(self):
    """size() - Returns a Numpy array of size 1 with the number of elements
    in the tensor associated with each frame
    """
    len_list = [self.frame_samples]
    return numpy.asarray(len_list)

    # You can create a numpy array from list l iwth np.asarray(l)


def seek_sample(self, N):
    "seek_sample(N) - Next iterator will start with sample N"
    if N >= self.frame_samples * len(self.frames):
        raise StopIteration
    else:
        frame_index = int(N / self.frames)
        for i in range(frame_index):
            self.iterator.__next__()


def get_data(self, startidx, N):
    """get_data(startidx, N) - Retrieve N samples starting at startidx.
    This has no side effects, the file position of iterators is unchanged.
    Raises a ValueError if outside range of signal.
    """
    if startidx + N > len(self.audio_data):
        raise ValueError
    else:
        return self.audio_data[startidx:startidx + N]
