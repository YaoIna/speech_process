# Add imports as needed
import numpy

from mydsp.audioframes import AudioFrames


class RMSStream:
    """RMSSTream
    Streamer object for root mean square intensity in dB
    Given an object of class AudioFrames
    """

    def __init__(self, frames: AudioFrames):
        "RMSSTream - root mean square stream from an AudioFrames object"
        if isinstance(frames, AudioFrames):
            data_list = list()
            for frame in frames:
                data_list.append(self.compute_rmss(frame))
            self.rms_data = numpy.array(data_list)

    def __iter__(self):
        "__iter_ - Return an object that iterates over RMS frame values"

        # Implementation decision
        # You can return self and implement a __next__(self) in this class
        # or you can create and return an instance of an iteration class
        # of your design that supports __next__(self).  In either case, the
        # __next__ method will return the next RMS value in dB rel.
        return iter(self.rms_data)

    def __getitem__(self, item):
        return self.rms_data[item]

    def __len__(self):
        "__len__() - Number of frames in stream"
        return len(self.rms_data)

    def shape(self):
        "shape() - shape of tensor generated by iterator"
        dimensions_list = list()
        dimensions_list.append(1)
        dimensions_list.append(1)
        return numpy.asarray(dimensions_list)

        # See descriptions in audioframes.py

    def size(self):
        "size() - number of elements in tensor generated by iterator"
        return len(self.rms_data)

    def compute_rmss(self, frame_data: list) -> float:

        if len(frame_data) == 0:
            return 0

        square_sum = 0
        for i in frame_data:
            data = float(i)
            square_sum = square_sum + numpy.square(data)

        if square_sum == 0:
            square_sum = 0.00001

        return 10 * numpy.log10(square_sum / len(frame_data))
